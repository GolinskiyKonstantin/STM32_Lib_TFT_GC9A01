/*	сохраняем данный файл в кодировке UTF-8		*/


 author: Golinskiy Konstantin	e-mail: golinskiy.konstantin@gmail.com
 
 
//===================================================

//----- SPI2 parameter configuration ----------------------------------------

// SPI включаем только передача ( MOSI SCK )
// настройка SPI, скорость максимальная, 1 Line (TX only), Polarity High, Phase 2Edge:

//-----------------------------------------------------------------------------



в файле fonts.h нужно выбрать шрифты:

//---- для экономии памяти шрифты которые не используються закоментировать -------------------------------------
			// Шрифт имеет кирилицу и латиницу
			#define FONT_6x8		//  6 x 8 pixels font size structure 
			#define FONT_7x9		//  7 x 9 pixels font size structure 
			#define FONT_11x18		//  11 x 18 pixels font size structure 
			#define FONT_16x26		//  16 x 26 pixels font size structure 
			// Только цифры -- only numbers
			#define FONT_16x28		//  16 x 28 pixels font size structure only numbers	
//--------------------------------------------------------------------------------------------------------------

в файле GC9A01.h указываем настройки:

//#######  SETUP  ##############################################################################################
		
		//==== выбераем через что будем отправлять через HAL или CMSIS(быстрее) ==================
		//-- нужное оставляем другое коментируем ( важно должно быть только один выбран )---------
		
			// указываем порт SPI для CMSIS ( быстро )-------
			// так как у разных МК разные регистры то в функциях корректируем под свой МК
			// на данный момент есть реализация на серию F1 F4 H7 для выбора серии в функциях
			//	void GC9A01_SendCmd(uint8_t Cmd);
			//	void GC9A01_SendData(uint8_t Data );
			//	void GC9A01_SendDataMASS(uint8_t* buff, size_t buff_size);	
			// комментируем и раскомментируем то что нам нужно, также там же редактируем под свой МК если не работает
			#define 	GC9A01_SPI_CMSIS 	SPI1
			//-----------------------------------------------
			
			// указываем порт SPI для HAL ( медлено )--------
			//#define 	GC9A01_SPI_HAL 		hspi1
			//-----------------------------------------------
			
			// выбираем как выводить информацию через буфер кадра или попиксельно ( 1-буфер кадра, 0-попиксельный вывод ) -----
			// через буфер быстре если много информации обнавлять за один раз ( требует много оперативки для массива )
			// по пиксельно рисует онлайн буз буферра если информация обновляеться немного то выгодно испотзовать данный режим
			#define FRAME_BUFFER				0
			//-----------------------------------------------------------------------------------------------------------------
			
			
		//============================================================================
		
		//=== указываем порты ( если в кубе назвали их DC RES CS то тогда нечего указывать не нужно )
		#if defined (DC_GPIO_Port)
		#else
			#define DC_GPIO_Port	GPIOC
			#define DC_Pin			GPIO_PIN_5
		#endif
		
		#if defined (RST_GPIO_Port)
		#else
			#define RST_GPIO_Port   GPIOB
			#define RST_Pin			GPIO_PIN_14
		#endif
		
		//--  Cесли используем порт CS для выбора устройства тогда раскомментировать ------------
		// если у нас одно устройство лучше пин CS притянуть к земле( или на порту подать GND )
		
		#define CS_PORT
		
		//----------------------------------------------------------------------------------------
		#ifdef CS_PORT
			#if defined (CS_GPIO_Port)
			#else
				#define CS_GPIO_Port    GPIOA
				#define CS_Pin			GPIO_PIN_4
			#endif
		#endif
		
		//=============================================================================
		
		//==  выбираем дисплей: =======================================================
		//-- нужное оставляем другое коментируем ( важно должно быть только один выбран )---------
		
		#define	GC9A01_IS_240X240		// 240 x 240 GC9A01 		
		//=============================================================================
		
		
//##############################################################################################################





//=========================================================



#include "GC9A01.h"

#include "bitmap.h"
#include "fonts.h"


#include "stdio.h"
	.........
	.........

main()=============================================================================================================================
	
/////////////////////////////////////////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------
	// Процедура инициализации дисплея GC9A01
	GC9A01_Init();	
//------------------------------------------------------------------


//------------------------------------------------------------------
	// установка ротации дисплея, отзеркаливание по вертикали и горизонтали и режим цветопередаци
	// первый параметр ротация значения от 0 до 7 
	// второй параметр отзеркаливание по вертикали значения 0-выкл 1-вкл
	// третий параметр отзеркаливание по горизонтали значения 0-выкл 1-вкл
	// по умолчанию стоит #define GC9A01_DEF_ROTATION  ( 0, 0, 0 )
	GC9A01_rotation( 3, 0, 0 );
//------------------------------------------------------------------	
	
//------------------------------------------------------------------	
//	// закрашиваем весь экран указаным цветом 
//	GC9A01_FillScreen( RGB565(255, 0, 0) );
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
	
//		// закрашиваем весь экран указаным цветом 
//	GC9A01_FillScreen( RGB565(0, 255, 0) );
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
	
//	// закрашиваем весь экран указаным цветом 
//	GC9A01_FillScreen( RGB565(0, 0, 255) );
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
	
//	// закрашиваем весь экран указаным цветом 
//	GC9A01_FillScreen( RGB565(57, 179, 185) );
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);

	
//------------------------------------------------------------------


//------------------------------------------------------------------
//		// очистка только буфера кадра  ( при етом сам экран не очищаеться )
//	#if FRAME_BUFFER	// если включен буфер кадра
//			GC9A01_ClearFrameBuffer();
//	#endif
//------------------------------------------------------------------

//------------------------------------------------------------------
//	// рисуем пиксель
//	GC9A01_DrawPixel( 12, 12, RGB565( 255, 255, 255 ) );
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//		HAL_Delay (1000);
//------------------------------------------------------------------

//------------------------------------------------------------------
//	// печатаем символ ( один ) параметры: х,  у, ( начиная с 0 ),  цвет символа, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сам символ ( поддерживает кириллицу )
//	GC9A01_DrawChar( 120, 20, RGB565( 228, 233, 50 ) , RGB565( 0, 10, 10 ) , 0, &Font_16x26, 1, 'F' );
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
//------------------------------------------------------------------

//------------------------------------------------------------------
//	// рисуем цветную иконку. параметры координаты х и у ( начиная с 0 ), размер иконки шир и выс, имя иконки ( массив )
//	GC9A01_DrawImage( 0, 0, 85, 80, logoRGB );
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
//------------------------------------------------------------------

	// очистка экрана - закрашивает экран цветом черный
	//GC9A01_Clear();


//------------------------------------------------------------------
//	// прямоугольник закрашеный ( координата X и Y ( начиная с 0 ) ширина и высота в пикселях )
//	GC9A01_DrawRectangleFilled(105, 105, 30, 30, RGB565(255, 255, 255)) ;
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
//------------------------------------------------------------------

	
//------------------------------------------------------------------	
//	for( uint8_t i = 0; i< GC9A01_Width; i+=3){
//		// прямоугольник закрашеный ( координата X и Y ( начиная с 0 ) ширина и высота в пикселях )
//		GC9A01_DrawRectangleFilled(i, i, GC9A01_Width-i, GC9A01_Height-i, RGB565(i/2, 255-i, 0+i)) ;
//	}
//	
//	for( uint8_t i = 0; i< GC9A01_Width/2; i+=3){
//		// прямоугольник пустотелый ( координата X и Y ( начиная с 0 ) ширина и высота в пикселях )
//		GC9A01_DrawRectangle(i, i, GC9A01_Width-i, GC9A01_Height-i, RGB565(255, 0, 0)) ;
//	}
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
//------------------------------------------------------------------

	// очистка экрана - закрашивает экран цветом черный
	//GC9A01_Clear();



//--- для вывода большого цветного изображения нужно много памяти 240 * 240 * 2 байт	----------
//	// рисуем цветную иконку. параметры координаты х и у ( начиная с 0 ), размер иконки шир и выс, имя иконки ( массив )
//	GC9A01_DrawImage( 80, 80, 85, 53, img0	);
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
//-----------------------------------------------------------------------------------------------	


//------------------------------------------------------------------
//	// печатаем строку параметры: х,  у, ( начиная с 0 ), цвет строки, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сама строка ( поддерживает кириллицу )
//	GC9A01_print( 1, 1, RGB565(255, 255, 255) , RGB565(0, 10, 100) , 1, &Font_16x26, 1, "STM32 TFT" );

//	// печатаем строку параметры: х,  у, ( начиная с 0 ),  цвет строки, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сама строка ( поддерживает кириллицу )
//	GC9A01_print( 1, 20, RGB565(255, 0, 0) , RGB565(0, 10, 100) , 1, &Font_11x18, 1, "Классный дисплей !!!" );

//	// печатаем строку параметры: х,  у, ( начиная с 0 ),  цвет строки, цвет фона, вкл/выкл фон, размер шрифта, множитель шрифта (увеличивает в х раз шрифт ), сама строка ( поддерживает кириллицу )
//	GC9A01_print( 1, 40, RGB565(0, 255, 0) , RGB565(0, 10, 100) , 1, &Font_7x9, 2, "GC9A01 : 240x240" );
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
//------------------------------------------------------------------	


	// очистка экрана - закрашивает экран цветом черный
	//GC9A01_Clear();


//------------------------------------------------------------------
//	// рисуем монохромную иконку. параметры координаты х и у ( начиная с 0 ), имя иконки ( массив ), размер иконки шир и выс, цвет отображения
//	GC9A01_DrawBitmap( 50, 50, logo, 128, 27, RGB565(255, 0, 255) );
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
//------------------------------------------------------------------

	// очистка экрана - закрашивает экран цветом черный
	//GC9A01_Clear();


//------------------------------------------------------------------
//	// круг пустотелый
//	GC9A01_DrawCircle(120-1, 120-1, 10, RGB565(255, 0, 255));
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
//------------------------------------------------------------------


//------------------------------------------------------------------

//		// рисованиe дуга толстая ( часть круга )
//		GC9A01_DrawArc(100, 100, 50, 90, 180, RGB565(255, 255, 0), 5);
		
//	// круг закрашеный
//	GC9A01_DrawCircleFilled(50, 290, 20, RGB565(255, 40, 255)) ;

//	// линия
//	GC9A01_DrawLine(1, 319, 239, 319, RGB565(255, 255, 0));
	
//		// линия толстая ( последний параметр толшина )
//		GC9A01_DrawLineThick(10, 120, 200, 140, RGB565(255, 255, 0), 5);

//	// прямоугольник закрашеный
//	GC9A01_DrawRectangleFilled(90, 265, 140, 310, RGB565(0, 255, 0)) ;
//	
//	// прямоугольник пустотелый
//	GC9A01_DrawRectangle(160, 265, 220, 309, RGB565(255, 255, 255)) ;	
//		
//	// рисуем треугольник пустотелый
//	GC9A01_DrawTriangle(60, 40, 150, 100, 200, 200, RGB565(100, 255, 150) );

//	// рисуем треугольник закрашеный
//	GC9A01_DrawFilledTriangle(20, 40, 150, 100, 200, 200, RGB565(100, 255, 150) );
//		
//	// рисуем прямоугольник с закругленными краями ( закрашенный )
//	GC9A01_DrawFillRoundRect(10, 10, 50, 50, 10, RGB565(100, 255, 150));
//	
//	// рисуем прямоугольник с закругленными краями ( пустотелый )
//	GC9A01_DrawRoundRect(10, 10, 50, 50, 10, RGB565(100, 255, 150));
//	
//	// рисуем полукруг ( правое или левое полушарие (параметр 1 или 2) ) закрашенный
//	GC9A01_DrawFillCircleHelper(30, 30, 20 , 1, 0, RGB565(100, 255, 150));
//	
//	// рисуем дугу ( четверть круга (параметр 1, 2, 4, 8) ) шириной 1 пиксель
//	GC9A01_DrawCircleHelper(30, 30, 20 , 1, RGB565(100, 255, 150));
//	
//#if FRAME_BUFFER	// если включен буфер кадра
//		GC9A01_Update();
//#endif
//	HAL_Delay (1000);
//------------------------------------------------------------------	


//------------------------------------------------------------------
//	// переход в спящий режим
//	GC9A01_SleepModeEnter();
//	HAL_Delay (1000);
//	
//	// выход их спящего режима
//	GC9A01_SleepModeExit();	
//	HAL_Delay (1000);
//	
//	// вкл/выкл дисплея 0-выкл 1- вкл
//	GC9A01_DisplayPower( 0 );
//	HAL_Delay (1000);
//	
//	// вкл/выкл дисплея 0-выкл 1- вкл
//	GC9A01_DisplayPower( 1 );
//	HAL_Delay (1000);
//	
//	// инверсия цветов 0-вкл  1-выкл
//	GC9A01_InversionMode(0);
//	HAL_Delay (1000);
//	
//	// инверсия цветов 0-вкл  1-выкл
//	GC9A01_InversionMode(1);
//	HAL_Delay (1000);
//------------------------------------------------------------------		




////////////////////////////////////////////////////////////////////////////////////////////
	
	
	.........
	.........
	.........

while(1)===========================================================================================================================

	.........
	.........
	.........
	.........

=== end while(1) ==================================================================================================================
=== end main() ====================================================================================================================



///////////////  ОТДЕЛЬНО КОД ДЛЯ АНАЛОГОВЫХ ЧАСОВ  ///////////////////////////////////

///////====  часы циферблад =============================================================================================
#define PI 	3.14159265
#define xC	120
#define yC	120

	
static void DrawArrow(int16_t angle, uint8_t lineLen, uint8_t thick, uint16_t color) {
	
	angle -= 90;
	float angleRad = (float) angle * PI / 180;
	int x = cos(angleRad) * lineLen + xC;
	int y = sin(angleRad) * lineLen + yC;

	GC9A01_DrawLineThick(xC, yC, x, y, color, thick);
}

void DrawClock(uint8_t hour, uint8_t min, uint8_t sec, uint8_t light, uint8_t secBubbles) {
	
	uint16_t bgColor, riskColor, digitColor, arrowColor, secArcColor;

	if (light) {
		bgColor = GC9A01_WHITE;
		riskColor = digitColor = arrowColor = GC9A01_BLACK;
		secArcColor = GC9A01_MAGENTA;
	} else {
		bgColor = GC9A01_BLACK;
		riskColor = digitColor = arrowColor = GC9A01_WHITE;
		secArcColor = GC9A01_GREEN;
	}

	GC9A01_FillScreen(bgColor);

	// Риски по окружности
	uint8_t radius1 = 119;
	for (uint16_t angle = 0; angle <= 360; angle += 6) {
		uint8_t riskSize;
		if (!(angle % 90))
			riskSize = 13;
		else if (!(angle % 30))
			riskSize = 10;
		else
			riskSize = 6;

		uint8_t radius2 = radius1 - riskSize;
		float angleRad = (float) angle * PI / 180;
		int x1 = cos(angleRad) * radius1 + xC;
		int y1 = sin(angleRad) * radius1 + yC;
		int x2 = cos(angleRad) * radius2 + xC;
		int y2 = sin(angleRad) * radius2 + yC;

		GC9A01_DrawLine(x1, y1, x2, y2, riskColor);
	}

	// Подписи часов
	GC9A01_print( 165, 30, digitColor , RGB565(0, 10, 100) , 0, &Font_11x18, 1, "1" );
	GC9A01_print( 200, 63, digitColor , RGB565(0, 10, 100) , 0, &Font_11x18, 1, "2" );
	GC9A01_print( 207, 110, digitColor , RGB565(0, 10, 100) , 0, &Font_16x26, 1, "3" );
	GC9A01_print( 200, 160, digitColor , RGB565(0, 10, 100) , 0, &Font_11x18, 1, "4" );
	GC9A01_print( 165, 193, digitColor , RGB565(0, 10, 100) , 0, &Font_11x18, 1, "5" );
	GC9A01_print( 110, 200, digitColor , RGB565(0, 10, 100) , 0, &Font_16x26, 1, "6" );
	GC9A01_print( 65, 193, digitColor , RGB565(0, 10, 100) , 0, &Font_11x18, 1, "7" );
	GC9A01_print( 32, 160, digitColor , RGB565(0, 10, 100) , 0, &Font_11x18, 1, "8" );
	GC9A01_print( 19, 110, digitColor , RGB565(0, 10, 100) , 0, &Font_16x26, 1, "9" );
	GC9A01_print( 32, 63, digitColor , RGB565(0, 10, 100) , 0, &Font_11x18, 1, "10" );
	GC9A01_print( 65, 30, digitColor , RGB565(0, 10, 100) , 0, &Font_11x18, 1, "11" );
	GC9A01_print( 106, 20, digitColor , RGB565(0, 10, 100) , 0, &Font_16x26, 1, "12" );


//	dispcolor_printf(75, 80, FONTID_16F, digitColor, "%02d : %02d : %02d", hour,
//			min, sec);

	// Минутная стрелка
	DrawArrow(min * 6 + sec / 10, 80, 2, arrowColor);
	// Часовая стрелка
	DrawArrow(hour * 30 + min / 2, 50, 4, arrowColor);

	// Секундная дуга
	if (!sec)
		sec = 60;
	if (secBubbles) {
		int16_t startAngle = -90;
		int16_t endAngle = sec * 6 - 90;

		for (int16_t angle = startAngle; angle <= endAngle; angle += 6) {
			float angleRad = (float) angle * PI / 180;
			int x = cos(angleRad) * 119 + xC;
			int y = sin(angleRad) * 119 + yC;

			if (angle == endAngle)
				GC9A01_DrawCircleFilled(x, y, 4, secArcColor);
			else
				GC9A01_DrawCircleFilled(x, y, 2, secArcColor);
		}
	} else
		GC9A01_DrawArc(xC, yC, 119, 0, sec * 6, secArcColor, 2);


	HAL_Delay(50);
}
//////////==============================================================================================		

//////////////////////////////////////////////////////////////////////////////////////////////////////////

//		for( uint8_t i = 0; i < 60; i++ ){
//			DrawClock(12, i, 59-i, 0, 0);
//			HAL_Delay( 1000 );
//		}